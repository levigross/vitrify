# MODULE: dm-verity Verified Boot
#
# Provides dm-verity support for transparent integrity verification of
# block devices. Supports signed root hashes for verified boot without
# requiring UEFI Secure Boot.
#
# dm-verity creates a read-only device-mapper target that verifies data
# integrity using a Merkle tree of cryptographic hashes.
{
  config,
  lib,
  pkgs,
  ...
}:
let
  cfg = config.vitrify.verity;

  # Generate veritysetup commands for a verity device
  mkVeritySetup = name: device: ''
    echo "Setting up dm-verity device: ${name}"
    veritysetup open \
      ${lib.escapeShellArg device.dataDevice} \
      ${lib.escapeShellArg name} \
      ${lib.escapeShellArg device.hashDevice} \
      ${lib.escapeShellArg device.rootHash} \
      ${lib.optionalString (device.hashOffset != null) "--hash-offset=${toString device.hashOffset}"} \
      ${lib.optionalString device.signatureVerification "--root-hash-signature=${lib.escapeShellArg device.signaturePath}"} \
      ${
        lib.optionalString (device.fecDevice != null) "--fec-device=${lib.escapeShellArg device.fecDevice}"
      } \
      ${lib.optionalString (device.fecRoots != null) "--fec-roots=${toString device.fecRoots}"}
  '';

  verityDeviceOptions = {
    options = {
      dataDevice = lib.mkOption {
        type = lib.types.str;
        description = "Path to the data device (or partition) to verify.";
        example = "/dev/disk/by-partlabel/rootfs";
      };

      hashDevice = lib.mkOption {
        type = lib.types.str;
        description = ''
          Path to the hash device containing the Merkle tree.
          Can be the same as dataDevice if hash is appended.
        '';
        example = "/dev/disk/by-partlabel/rootfs-hash";
      };

      hashOffset = lib.mkOption {
        type = lib.types.nullOr lib.types.int;
        default = null;
        description = ''
          Byte offset of hash data in hashDevice.
          Use when hash tree is appended to data device.
        '';
        example = 1073741824;
      };

      rootHash = lib.mkOption {
        type = lib.types.str;
        description = ''
          The root hash of the Merkle tree (hex string).
          Generated by veritysetup format.
        '';
        example = "4392712ba01368efdf14b05c76f9e4df0d53664630b5d48632ed17a137f39076";
      };

      signatureVerification = lib.mkOption {
        type = lib.types.bool;
        default = true;
        description = ''
          Whether to verify the root hash signature.
          Requires the signing key to be in the kernel keyring.
        '';
      };

      signaturePath = lib.mkOption {
        type = lib.types.str;
        default = "/etc/verity-signatures/root.p7s";
        description = ''
          Path to the PKCS#7 signature file for the root hash.
          The signature must be created with a key trusted by the kernel.
        '';
      };

      fecDevice = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        description = ''
          Optional forward error correction (FEC) device.
          Allows recovery from some data corruption.
        '';
      };

      fecRoots = lib.mkOption {
        type = lib.types.nullOr lib.types.int;
        default = null;
        description = "Number of FEC roots (parity bytes). Higher = more recovery capability.";
        example = 2;
      };

      mountPoint = lib.mkOption {
        type = lib.types.nullOr lib.types.str;
        default = null;
        description = ''
          If set, mount this verity device at the specified path.
          The device will be mounted read-only.
        '';
        example = "/";
      };
    };
  };
in
{
  options.vitrify.verity = {
    enable = lib.mkEnableOption "dm-verity verified boot support";

    devices = lib.mkOption {
      type = lib.types.attrsOf (lib.types.submodule verityDeviceOptions);
      default = { };
      description = ''
        Attribute set of dm-verity devices to configure.
        Each device creates a verified block device at /dev/mapper/<name>.
      '';
      example = lib.literalExpression ''
        {
          root = {
            dataDevice = "/dev/disk/by-partlabel/rootfs";
            hashDevice = "/dev/disk/by-partlabel/rootfs";
            hashOffset = 1073741824;
            rootHash = "4392712ba01368efdf14b05c76f9e4df0d53664630b5d48632ed17a137f39076";
            signaturePath = "/etc/verity-signatures/root.p7s";
            mountPoint = "/";
          };
        }
      '';
    };

    trustedKeys = lib.mkOption {
      type = lib.types.listOf lib.types.path;
      default = [ ];
      description = ''
        List of X.509 certificates (DER format) to add to the kernel's
        secondary trusted keyring for root hash signature verification.
      '';
      example = [ ./keys/verity-signing.der ];
    };

    overlay = {
      enable = lib.mkEnableOption ''
        overlay filesystem on verified root.
        Creates a writable layer on top of the read-only verified root.
      '';

      upperDir = lib.mkOption {
        type = lib.types.str;
        default = "/mnt/overlay/upper";
        description = "Path to the writable upper directory for overlayfs.";
      };

      workDir = lib.mkOption {
        type = lib.types.str;
        default = "/mnt/overlay/work";
        description = "Path to the overlayfs work directory.";
      };
    };
  };

  config = lib.mkIf cfg.enable {
    # Note: Kernel config for dm-verity is in the hardenedKernel module
    # This module configures the userspace components and systemd services

    # Include cryptsetup/veritysetup in initrd
    boot.initrd.availableKernelModules = [
      "dm_verity"
      "dm_mod"
    ];

    boot.initrd.systemd.enable = lib.mkDefault true;

    boot.initrd.systemd.contents = lib.mkIf (cfg.trustedKeys != [ ]) {
      "/etc/keys/verity" = {
        source = pkgs.runCommand "verity-keys" { } ''
          mkdir -p $out
          ${lib.concatMapStringsSep "\n" (key: ''
            cp ${key} $out/$(basename ${key})
          '') cfg.trustedKeys}
        '';
      };
    };

    # Include veritysetup in initrd
    boot.initrd.extraUtilsCommands = lib.mkIf (!config.boot.initrd.systemd.enable) ''
      copy_bin_and_libs ${pkgs.cryptsetup}/bin/veritysetup
    '';

    boot.initrd.systemd.packages = lib.mkIf config.boot.initrd.systemd.enable [
      pkgs.cryptsetup
    ];

    # Add kernel command line parameters for dm-verity
    boot.kernelParams = lib.mkIf (cfg.devices != { }) [
      # Enable dm-verity signature verification
      "dm_verity.require_signatures=1"
    ];

    # System packages for verity management
    environment.systemPackages = [ pkgs.cryptsetup ];

    # Create signature directory
    systemd.tmpfiles.rules = lib.mkIf (cfg.devices != { }) [
      "d /etc/verity-signatures 0700 root root -"
    ];

    # Generate systemd service for each verity device (for non-root devices)
    systemd.services = lib.mapAttrs' (
      name: device:
      lib.nameValuePair "verity-${name}" {
        description = "dm-verity setup for ${name}";
        wantedBy = lib.optional (device.mountPoint != "/" && device.mountPoint != null) "local-fs.target";
        before = lib.optional (device.mountPoint != null) "local-fs.target";
        after = [ "systemd-udevd.service" ];

        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = true;
          ExecStart = pkgs.writeShellScript "verity-setup-${name}" (mkVeritySetup name device);
          ExecStop = "${pkgs.cryptsetup}/bin/veritysetup close ${lib.escapeShellArg name}";
        };
      }
    ) (lib.filterAttrs (_: d: d.mountPoint != "/") cfg.devices);

    # Add fileSystems entries for verity devices with mountPoints
    fileSystems = lib.mapAttrs' (
      name: device:
      lib.nameValuePair device.mountPoint {
        device = "/dev/mapper/${name}";
        fsType = "auto";
        options = [ "ro" ];
        depends = [ device.dataDevice ];
      }
    ) (lib.filterAttrs (_: d: d.mountPoint != null && d.mountPoint != "/") cfg.devices);

    # Assertions for configuration validation
    assertions = [
      {
        assertion =
          cfg.devices != { }
          -> cfg.trustedKeys != [ ] || !(lib.any (d: d.signatureVerification) (lib.attrValues cfg.devices));
        message = ''
          vitrify.verity: Signature verification is enabled but no trusted keys are provided.
          Either set vitrify.verity.trustedKeys or disable signatureVerification on devices.
        '';
      }
    ];

    warnings =
      let
        rootDevices = lib.filterAttrs (_: d: d.mountPoint == "/") cfg.devices;
      in
      lib.optional (rootDevices != { }) ''
        vitrify.verity: Root filesystem verity (mountPoint = "/") requires manual
        initrd configuration. The verity device must be set up before the root
        filesystem is mounted. Consider using boot.initrd.systemd with a custom
        generator or using the NixOS image-based approach with systemd-repart.
      '';
  };
}
